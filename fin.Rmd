---
title: "BT2201 Finance Project Notebook"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

This notebook quantifies the analysis we conducted to arrive at our optimal asset allocations.


## 1. Determine Investment Policy

Which products should be offered to a typical Japanese retail investor


### Risk Appetite

The typical Japanese retail investor is risk averse. Many older Japanese investors lived through the Asian Financial Crisis which saw a huge asset bubble and subsequent crash in Japanese financial markets. Those who invested money right at the peak of the asset bubble would have lost a considerable amount of money. Japan also entered many years of deflation afterwards.

Therefore, a typical Japanese retail investor is distinct from an American or European retail investor in that they have experienced more market downside and less economic euphoria. We expect that they will have a more conservative risk appetite and less tolerance for portfolio drawdown.


### Objective Function

Given the conditions described above, we choose to adopt the *Efficient Risk* or *Markowitz Portfolio*

**Fix Return and Minimise Risk**

(OR find an objective function from here)
https://pyportfolioopt.readthedocs.io/en/latest/MeanVariance.html 

For a start, maximise Sharpe:

$max \ \frac{E(R) - r_f}{SD(R)}$


### Amount
As stated in the preamble, investable amount is **JPY 100,000**.

### Choice of Assets

We start with the basket of ETFs provided

- BIV: US INTERMEDIATE BOND
- VCSH: US INVESTMENT GRADE BOND
- BNDX: GLOBAL BOND ETF
- VNQ: US REIT
- JP 1343: JREIT
- JP 1555: AU REIT
- SPDR: US STOCK
- VT: GLOBAL STOCK
- HVST AU: EQUITY DIVIDEND ETF AU

We choose an allocation of 40% Bond and 60% Equity to reflect the risk appetite we have chosen.


## 2. Security Analysis

Pull data for tickers described above.
```{r}
#install quantmod, xml2
require(quantmod)

```

```{r}


global_etf = c('BIV', # US INTERMEDIATE BOND
            'VCSH',# US INVESTMENT GRADE BOND
            'BNDX',# GLOBAL BOND ETF
            'VNQ', #US REIT
            'VT', #GLOBAL STOCK'
            'SPY' #US STOCK (SPDR)
)

j_etf = c('1343.T',  # JREIT (JP 1343)
          '1555.T' # AU REIT (JP 1555)
)
           
au_etf = c('HVST.AX' #EQUITY DIVIDEND ETF AU (HVST AU)
)
            
getSymbols(global_etf, auto.assign = T)
getSymbols(j_etf, auto.assign = T, src='yahooj')
getSymbols(au_etf, auto.assign = T)

```
Find out characteristics of each of all the tickers.

### Plots

```{r}
tickers = list(BIV,VCSH,BNDX,VNQ,VT,SPY,`YJ1343.T`,`YJ1555.T`,HVST.AX)
name = list('BIV','VCSH','BNDX','VNQ','VT','SPY','YJ1343.T','YJ1555.T','HVST.AX')

t = BIV
init.d <- index(t)[1]
e <- t[, 6]/as.numeric(t[init.d, 6])
plot(e, main=names(e))
t = VCSH
init.d <- index(t)[1]
e <- t[, 6]/as.numeric(t[init.d, 6])
plot(e, main=names(e))
t = BNDX
init.d <- index(t)[1]
e <- t[, 6]/as.numeric(t[init.d, 6])
plot(e, main=names(e))
t = VNQ
init.d <- index(t)[1]
e <- t[, 6]/as.numeric(t[init.d, 6])
plot(e, main=names(e))
t = VT
init.d <- index(t)[1]
e <- t[, 6]/as.numeric(t[init.d, 6])
plot(e, main=names(e))
t = SPY
init.d <- index(t)[1]
e <- t[, 6]/as.numeric(t[init.d, 6])
plot(e, main=names(e))
t = `YJ1343.T`
init.d <- index(t)[1]
e <- t[, 6]/as.numeric(t[init.d, 6])
plot(e, main=names(e))
t = `YJ1555.T`
init.d <- index(t)[1]
e <- t[, 6]/as.numeric(t[init.d, 6])
plot(e, main=names(e))
t = `HVST.AX`
init.d <- index(t)[1]
e <- t[, 6]/as.numeric(t[init.d, 6])
plot(e, main=names(e))
```


### Returns
Next, calculate Returns and Volatiliy ($\mu \ and \ \sigma$) for each of the ETFs

```{r}
means = c()
sds = c()
returns = c()
all_prices_monthly = c()
for(i in seq(9)){
  ticker = tickers[i][[1]]
  prices_monthly <- to.monthly(ticker, name=name[i], indexAt = "lastof", OHLC = T)
  return <- ROC(Ad(prices_monthly))
  returns = cbind(returns,return)
  means = c(means, mean(return, na.rm=T))
  sds = c(sds, sd(return, na.rm=T))
  all_prices_monthly = cbind(all_prices_monthly, Ad(prices_monthly))
}
df = data.frame(unlist(name), means, sds)
colnames(df) = c('ETF','Mu_Monthly', 'Sigma_Monthly')
df
```
```{r}
library(fPortfolio)
library(purrr)
returns = data.frame(returns)

colnames(returns) <- unlist(map(colnames(returns), function(x){unlist(strsplit(x,'[.]'))[1]}))
covdata = cov(returns, use = "complete.obs")

corrdata = cor(returns, use='complete.obs')
heatmap(corrdata)
```
## 3. Portfolio Construction
```{r}
# returns
pSpec = portfolioSpec()
# setSolver(pSpec) <- "solveRshortExact"
# annual_target = 0.05
# (1+annual_target)**(1/12) - 1
# setTargetReturn(pSpec) = (1+annual_target)**(1/12) - 1
tangencyPortfolio(as.timeSeries(returns[complete.cases(returns),]))

```
```{r}
# Low: 0.0144, Med: 0.0289, High: 0.0722

# Low Risk Portfolio
pSpec = portfolioSpec()
# setSolver(pSpec) <- "solveRglpk.MAD"
annual_target = 0.065
target_return = (1+annual_target)**(1/12) - 1
# annual_risk = 0.05
# target_risk = annual_risk/sqrt(12)
# setTargetRisk(pSpec) = target_risk
# setOptimize(pSpec) = 'maxReturn'
setTargetReturn(pSpec) = target_return
data = portfolioData(as.timeSeries(returns[complete.cases(returns),]))

port = efficientPortfolio(data=as.timeSeries(returns[complete.cases(returns),]), spec=pSpec)

port
```
```{r}
# Low: 0.0144, Med: 0.0289, High: 0.0722

# Medium Risk Portfolio
pSpec = portfolioSpec()
annual_target = 0.11
target_return = (1+annual_target)**(1/12) - 1

setTargetReturn(pSpec) = target_return
data = portfolioData(as.timeSeries(returns[complete.cases(returns),]))

port = efficientPortfolio(data=as.timeSeries(returns[complete.cases(returns),]), spec=pSpec)

port
```
```{r}
# Low: 0.0144, Med: 0.0289, High: 0.0722

# High Risk Portfolio
pSpec = portfolioSpec()
annual_target = 0.2
target_return = (1+annual_target)**(1/12) - 1

setTargetReturn(pSpec) = target_return
data = portfolioData(as.timeSeries(returns[complete.cases(returns),]))

port = efficientPortfolio(data=as.timeSeries(returns[complete.cases(returns),]), spec=pSpec)

port
```
## 4. Portfolio Implementation


## 5. Portfolio Evaluation


## 6. Portfolio Revisions

### We consider a new candidate set of ETFs:
- VTI Vanguard Total Stock Market ETF (VTI)
- VEA Vanguard FTSE Developed Markets ETF
- VGT	Vanguard Information Technology ETF 
- XLF Financial Select Sector SPDR Fund 
- XLV	Health Care Select Sector SPDR Fund	
- XLE Energy Select Sector SPDR Fund
- XLI Industrial Select Sector SPDR Fund
- VNQ (Already in List)
- XLY Consumer Discretionary Select Sector SPDR Fund
- VAW Vanguard Materials ETF
- XLP Consumer Staples Select Sector SPDR Fund
- VPU Vanguard Utilities ETF


These ETFs have been selected with the considerations of:

- Focused on large cap companies to reduce systematic risk
- Highly liquid with average daily trading volume above 100k
- USD denominated to reduce the risk of forex
- Diversification in ETF holdings and sectors (based on the 11 GICS sectors)
- Diversification in terms of markets i.e. EM, US, bond


```{r}
new_etf= c(
  'VTI',
  'VEA',
  'VGT',
  'XLF',
  'XLE',
  'XLI',
  'XLY',
  'VAW',
  'XLP',
  'VPU'
)

benchmarks = c(
  'CRSPTM1', # CRSP US Total Market Index, for VTI
  'AD09', # FTSE Developed All Cap ex US Index, for VEA
  'IXM', # Financial Select Sector Index
  'IXV', # Healthcare Select Sector Index
  'IXE', # Energy Select Sector Index
  'IXI', # Industrial Select Sector Index
  'IXY', # Consumer Discretionary Select Sector Index
  'IXR', # Consumer Staples Select Sector Index
  'IXU' # Utilities Select Sector Index
  )



getSymbols(new_etf, auto.assign=T)

```
```{r}
new_tickers = list(VTI, VEA, VGT, XLF, XLE, XLI, XLY, VAW, XLP, VPU)
new_name = new_etf

t = VTI
init.d <- index(t)[1] # first date
e <- t[, 6]/as.numeric(t[init.d, 6]) # adjusted values / first adjusted value
plot(e, main=names(e))
```
```{r}
t = VEA
init.d <- index(t)[1] # first date
e <- t[, 6]/as.numeric(t[init.d, 6]) # adjusted values / first adjusted value
plot(e, main=names(e))
```
```{r}
t = VGT
init.d <- index(t)[1] # first date
e <- t[, 6]/as.numeric(t[init.d, 6]) # adjusted values / first adjusted value
plot(e, main=names(e))
```
```{r}
t = XLF
init.d <- index(t)[1] # first date
e <- t[, 6]/as.numeric(t[init.d, 6]) # adjusted values / first adjusted value
plot(e, main=names(e))
```
```{r}
t = XLE
init.d <- index(t)[1] # first date
e <- t[, 6]/as.numeric(t[init.d, 6]) # adjusted values / first adjusted value
plot(e, main=names(e))
```
```{r}
t = XLI
init.d <- index(t)[1] # first date
e <- t[, 6]/as.numeric(t[init.d, 6]) # adjusted values / first adjusted value
plot(e, main=names(e))
```
```{r}
t = XLY
init.d <- index(t)[1] # first date
e <- t[, 6]/as.numeric(t[init.d, 6]) # adjusted values / first adjusted value
plot(e, main=names(e))
```
```{r}
t = VAW
init.d <- index(t)[1] # first date
e <- t[, 6]/as.numeric(t[init.d, 6]) # adjusted values / first adjusted value
plot(e, main=names(e))
```
```{r}
t = XLP
init.d <- index(t)[1] # first date
e <- t[, 6]/as.numeric(t[init.d, 6]) # adjusted values / first adjusted value
plot(e, main=names(e))
```
```{r}
t = VPU
init.d <- index(t)[1] # first date
e <- t[, 6]/as.numeric(t[init.d, 6]) # adjusted values / first adjusted value
plot(e, main=names(e))
```
```{r}
new_means = c()
new_sds = c()
new_returns = c()
for(i in seq(length(new_etf))){
  ticker = new_tickers[i][[1]]
  prices_monthly <- to.monthly(ticker, name=new_name[i], indexAt = "lastof", OHLC = T)
  return <- ROC(Ad(prices_monthly))
  new_returns = cbind(new_returns,return)
  new_means = c(new_means, mean(return, na.rm=T))
  new_sds = c(new_sds, sd(return, na.rm=T))
}
new_df = data.frame(unlist(new_name), new_means, new_sds)
colnames(new_df) = c('ETF','Mu_Monthly', 'Sigma_Monthly')
new_df
```
```{r}
library(fPortfolio)
library(purrr)
new_returns = data.frame(new_returns)

colnames(new_returns) <- unlist(map(colnames(new_returns), function(x){unlist(strsplit(x,'[.]'))[1]}))
covdata = cov(new_returns, use = "complete.obs")

corrdata = cor(new_returns, use='complete.obs')
heatmap(corrdata)
```
```{r}

all_returns = cbind(returns, new_returns)
all_returns
```
```{r}

data = portfolioData(as.timeSeries(all_returns[complete.cases(all_returns),]))
port = tangencyPortfolio(data=data)

port
```
```{r}
# Low: 0.0144, Med: 0.0289, High: 0.0722
# Low Risk Portfolio
pSpec = portfolioSpec()
annual_target = 0.077
target_return = (1+annual_target)**(1/12) - 1
# 
setTargetReturn(pSpec) = target_return
# data = portfolioData(as.timeSeries(returns[complete.cases(returns),]))
data = portfolioData(as.timeSeries(all_returns[complete.cases(all_returns),]))
port = efficientPortfolio(data=data, spec=pSpec)

port
```
```{r}
# Low: 0.0144, Med: 0.0289, High: 0.0722
# Medium Risk Portfolio
pSpec = portfolioSpec()
annual_target = 0.14
target_return = (1+annual_target)**(1/12) - 1
# 
setTargetReturn(pSpec) = target_return
# data = portfolioData(as.timeSeries(returns[complete.cases(returns),]))
data = portfolioData(as.timeSeries(all_returns[complete.cases(all_returns),]))
port = efficientPortfolio(data=data, spec=pSpec, constraints=c('maxW[1:19]=0.2'))

port
```
```{r}
# Low: 0.0144, Med: 0.0289, High: 0.0722
# High Risk Portfolio
pSpec = portfolioSpec()
annual_target = 0.16
target_return = (1+annual_target)**(1/12) - 1
# 
setTargetReturn(pSpec) = target_return
# data = portfolioData(as.timeSeries(returns[complete.cases(returns),]))
data = portfolioData(as.timeSeries(all_returns[complete.cases(all_returns),]))
port = efficientPortfolio(data=data, spec=pSpec, constraints=c('maxW[1:19]=0.2'))

port
```

# Efficient Frontier Plot


```{r}

setNFrontierPoints(pSpec) <- 20

longFrontier <- portfolioFrontier(data = data, spec = pSpec)

col = qualiPalette(30, "Set1")
tailoredFrontierPlot(longFrontier, return = "mean", risk = "Cov")
grid()
singleAssetPoints(longFrontier, col='red')

```





```{r}



```









# Experimentation with Target Risk and Short Selling (for screenshots)
```{r}
pSpec = portfolioSpec()
annual_risk = 0.05
target_risk = annual_risk/sqrt(12)
setTargetRisk(pSpec) = target_risk
data = portfolioData(as.timeSeries(returns[complete.cases(returns),]))
port = maxreturnPortfolio(data, spec=pSpec)

port
```
```{r}
pSpec = portfolioSpec()
annual_risk = 0.1
target_risk = annual_risk/sqrt(12)
setTargetRisk(pSpec) = target_risk
data = portfolioData(as.timeSeries(returns[complete.cases(returns),]))
port = maxreturnPortfolio(data, spec=pSpec)

port
```
```{r}
pSpec = portfolioSpec()
annual_risk = 0.1
target_risk = annual_risk/sqrt(12) #0.0289
setSolver(pSpec) = 'solveRshortExact'
setTargetRisk(pSpec) = target_risk
data = portfolioData(as.timeSeries(returns[complete.cases(returns),]))
port = maxreturnPortfolio(data, spec=pSpec)
print(target_risk)
port
```

```{r}
pSpec = portfolioSpec()
annual_target = 0.1
target_return = (1+annual_target)**(1/12) - 1 #0.00797
setTargetReturn(pSpec) = target_return
data = portfolioData(as.timeSeries(returns[complete.cases(returns),]))
port = efficientPortfolio(data, spec=pSpec)
print(target_return)
port
```